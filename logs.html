<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ’¾</text></svg>">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Starter Logs</title>
  <meta property="og:title" content="Starter" />
  <meta property="og:locale" content="en_US" />
  <meta name="description" content="Logs of Progress" />
  <meta property="og:description" content="Logs of Progress" />
  <link rel="canonical" href="https://nan-academy.github.io/starter/logs" />
  <meta property="og:url" content="https://nan-academy.github.io/starter/logs" />
  <meta property="og:site_name" content="starter" />
  <meta name="twitter:card" content="summary" />
  <meta property="twitter:title" content="Init" />
  <script type="application/ld+json">
      { "@type": "WebPage", "url": "https://nan-academy.github.io/starter/logs", "headline": "Starter Logs", "description": "Logs of Progress", "@context": "https://schema.org" }
  </script>
  <style id="root-style">
body {
  font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,Arial,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol";
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
  color: #24292e;
}

h1, h2 {
  padding-bottom: 0.3em;
  font-size: 2em;
  margin-bottom: 16px;
  font-weight: 600;
  line-height: 1.25;
}

h2 i { color: #aaa }
h2 {
  font-size: 1.5em;
  border-bottom: 1px solid #eaecef;
}

h3 {
  display: flex;
  justify-content: space-between;
}

  </style>

</head>
<body>
<h1>ðŸ’¾ Logs</h1>
<h2 id="name-">Loadings...</h2>
<section>
</section>
<script type="module">
const cache = {
  get: (k, v) => localStorage[`starter@${k}`] || cache.set(k, v),
  set: (k, v) => v == null
    ? localStorage.removeItem(`starter@${k}`)
    : (localStorage[`starter@${k}`] = v)
}

const splitAt = (str, char) => {
  const index = str.indexOf(char)
  return index < 0 ? [str] : [str.slice(0, index), str.slice(index + 1)]
}

const parseLine = line => {
  const [time, rest] = splitAt(line, '@')
  const [session, data] = splitAt(rest, ':')
  const { key, code, pass } = JSON.parse(data)
  const [quest, exercise] = key.split('/')
  return { session, time: Number(time), quest, exercise, code, pass }
}

const total = arr => arr.reduce((a, b) => a + b, 0)
const mean = arr => arr.length && (total(arr) / arr.length)
// a mix median and mean
const normalizedAverage = arr => {
  const ordered = arr.sort((a, b) => a - b)

  // get a large median range (1/4)
  // this trim of the extremes values
  const padding = Math.ceil(ordered.length / 4)
  const range = ordered.slice(padding, -padding)

  // compute the mean of the rest
  return mean(range)
}

const M = 60000
const byTime = (a, b) => a.time - b.time
function parseLogs(logs) {

  // compute normalized average attempt time
  let prevTime = 0
  for (const log of logs) {
    log.elapsed = Math.min(log.time - prevTime, 90*M)
    prevTime = log.time
  }

  const average = normalizedAverage(logs.map(log => log.elapsed))

  // TODO: decouple timings computation and structure
  //       and make a quest per quest average hestimation

  // generate structure
  prevTime = 0
  const quests = {}
  for (const { exercise, quest, session, ...attempt } of logs) {
    const q = quests[quest] || (quests[quest] = {})
    const e = q[exercise] || (q[exercise] = {
      quest,
      name: exercise,
      attempts: [],
      start: Math.max(prevTime, attempt.time - average*2),
      active: 0,
    })

    if (e.pass) {
      // just update final solution if exercise is already validated
      attempt.pass && (e.code = attempt.code)
      continue
    }

    attempt.deviation = attempt.elapsed - average
    e.attempts.push(attempt)
    if (attempt.pass) {
      prevTime = e.end = attempt.time
      e.elapsed = e.end - e.start
      e.pass = true
      e.code = attempt.code
      e.active += total(e.attempts.map(a => Math.min(a.elapsed, average*1.5)))
    }
  }

  // TODO: fetch quest, parse title and list exercise with 0 attempts

  return {
    name: getName(quests[1]['anything-to-declare'].code),
    session: logs[0]?.session || '???',
    quests,
    attemptAverage: Math.round(average / 1000),
    elapsedAverage: Math.round(normalizedAverage(Object.values(quests[1]).map(e => e.elapsed))/1000),
    activeAverage: Math.round(normalizedAverage(Object.values(quests[1]).map(e => e.active))/1000),
  }
}

const makeExerciseMarkup = exercise => {
  return `<h3>${exercise.name} <b>${Math.round(exercise.active/1000)}s/<i>${exercise.attempts.length}</i></b></h3>`
}

const showSession = (strLogs) => {
  const metrics = parseLogs(strLogs)
  document.querySelector('h2').innerHTML = `${metrics.name} <i>${params.get('session')}<i>`
  document.querySelector('section').innerHTML = Object.values(metrics.quests[1])
    .sort((a, b) => a.start - b.start)
    .map(makeExerciseMarkup)
    .join('\n')

  console.log(window.metrics = metrics)
}

const getName = code => {
  try {
    return eval(`${code};\nname`)
      .slice(0, 20)
      .replace(/[&<>'"]/g, e => `&#${e.charCodeAt(0)};`)
  } catch {
    return '???'
  }
}

//*/

const query = async q => {
  const search = new URLSearchParams({ q })
  const res = await fetch(`https://nan.oct.ovh:8443/starter-progress?${search}`)
  const txt = await res.text()
  return txt.trim().split('\n').map(parseLine).sort(byTime)
}

const params = new URLSearchParams(location.search)

if (params.has('session')) {
  query(`@${params.get('session')}:{`).then(showSession, console.warn) 
} else {
  query('"1/anything-to-declare","pass":true').then(allLogs => {
    const uniqLogs = [...new Map(allLogs.map(l => [l.session, l])).values()]
    document.querySelector('h2').innerHTML = `List <i>${uniqLogs.length} found<i>`
    document.querySelector('section').innerHTML = uniqLogs
      .map(log => `<div><a href="${location.pathname}?session=${log.session}">${getName(log.code)} <i>(${log.session})</i></a>${Math.round((Date.now() - log.time)/1000)}</div>`)
      .join('\n')
  })
}

</script>
</body>
</html>